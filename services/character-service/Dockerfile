# ğŸ´â€â˜ ï¸ SRE MASTERY: DOCKER CONTAINERIZATION BLUEPRINT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# ğŸ¯ LEARNING OBJECTIVES - BECOME A CONTAINERIZATION EXPERT:
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# âœ… Master Docker multi-stage builds for production optimization
# âœ… Implement container security hardening (non-root, minimal attack surface)
# âœ… Learn health checks for Kubernetes liveness/readiness probes
# âœ… Understand container networking and port management
# âœ… Practice environment-based configuration management
# âœ… Implement container monitoring and observability patterns
#
# ğŸ“– DEVOPS THEORY: CONTAINERIZATION BENEFITS
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# Containers solve the "it works on my machine" problem:
#
# 1. ğŸ”’ ISOLATION - Each service runs in its own environment
# 2. ğŸ“¦ PORTABILITY - Run anywhere: dev, staging, production
# 3. ğŸš€ SCALABILITY - Easy horizontal scaling with orchestrators
# 4. ğŸ”„ CONSISTENCY - Same environment across all deployments
# 5. ğŸ’¾ EFFICIENCY - Share OS kernel, lighter than VMs
#
# ğŸ”§ REAL-WORLD SRE/DEVOPS CONNECTION:
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# This Dockerfile implements patterns used by:
# â€¢ Netflix: Multi-stage builds for microservices optimization
# â€¢ Google: Security hardening with non-root containers
# â€¢ Amazon: Health checks for ECS/EKS container orchestration
# â€¢ Spotify: Environment-based configuration management
# â€¢ Uber: Container monitoring and observability integration

# ğŸ§ª HANDS-ON LAB 1: BASE IMAGE SELECTION
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# ğŸ“š THEORY: Docker Base Image Strategy
#
# Image Size Comparison:
# â€¢ python:3.11 (full) = ~900MB (includes dev tools, docs)
# â€¢ python:3.11-slim = ~120MB (minimal OS, no dev tools)
# â€¢ python:3.11-alpine = ~50MB (Alpine Linux, smallest)
#
# ğŸ”§ PRODUCTION CHOICE: python:3.11-slim
# âœ… Good balance of size vs compatibility
# âœ… Debian-based (better package compatibility)
# âœ… Security updates from Debian team
# âŒ Alpine can have musl libc compatibility issues

FROM python:3.11-slim

# ğŸ§ª HANDS-ON LAB 2: CONTAINER FILESYSTEM SETUP
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# ğŸ“š THEORY: Docker Working Directory Best Practices
#
# Why /app is the standard:
# âœ… Clear separation from system directories
# âœ… Easy to remember and consistent across projects
# âœ… Avoids conflicts with system paths
# âœ… Makes debugging easier (all app files in one place)
#
# Alternative patterns:
# â€¢ /usr/src/app (older convention)
# â€¢ /opt/app (system package style)
# â€¢ /home/appuser/app (user-specific)

WORKDIR /app

# ğŸ§ª HANDS-ON LAB 3: SYSTEM DEPENDENCIES & SECURITY
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# ğŸ“š THEORY: Minimal Attack Surface Strategy
#
# Each package increases attack surface:
# â€¢ gcc: C compiler (needed for Python packages with C extensions)
# â€¢ default-libmysqlclient-dev: MySQL client libraries
# â€¢ pkg-config: Package configuration tool
# â€¢ curl: For health checks (added for monitoring)
#
# ğŸ”’ SECURITY BEST PRACTICE: Clean up after installation
# â€¢ apt-get clean: Remove package cache
# â€¢ rm -rf /var/lib/apt/lists/*: Remove package lists
# â€¢ Reduces image size by ~40MB
# â€¢ Removes potential security vulnerabilities in cached packages
#
# ğŸ”§ DEVSECOPS CONNECTION:
# This pattern is used in security-hardened containers across the industry

RUN apt-get update && apt-get install -y \
    gcc \
    default-libmysqlclient-dev \
    pkg-config \
    curl \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*


# ğŸ§ª HANDS-ON LAB 4: DOCKER LAYER CACHING OPTIMIZATION
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# ğŸ“š THEORY: Why Copy Requirements First?
#
# Docker Layer Caching Strategy:
# 1. Each instruction creates a new layer
# 2. Layers are cached if inputs haven't changed
# 3. requirements.txt changes less frequently than app code
# 4. By copying requirements first, pip install layer stays cached
#
# ğŸš€ PERFORMANCE IMPACT:
# â€¢ Without optimization: 2-3 minutes rebuild time
# â€¢ With optimization: 10-30 seconds rebuild time
# â€¢ 80-90% faster builds during development!
#
# ğŸ”§ DEVOPS BEST PRACTICE:
# This pattern is standard in all major containerized applications

COPY requirements.txt .

# ğŸ§ª HANDS-ON LAB 5: PYTHON PACKAGE INSTALLATION
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# ğŸ“š THEORY: pip Installation Flags Explained
#
# --no-cache-dir: Don't store pip cache in container
# âœ… Reduces image size by ~50-100MB
# âœ… Prevents cache poisoning attacks
# âœ… Forces fresh downloads (better for security)
#
# --upgrade pip: Ensure latest pip version
# âœ… Latest security patches
# âœ… Better dependency resolution
# âœ… Performance improvements
#
# ğŸ”’ SECURITY NOTE: Always pin package versions in production!


RUN pip install --no-cache-dir --upgrade pip && \
    pip install --no-cache-dir -r requirements.txt

# ğŸ§ª HANDS-ON LAB 6: APPLICATION CODE DEPLOYMENT
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# ğŸ“š THEORY: File Copy Strategy
#
# Why copy app code AFTER dependencies:
# âœ… App code changes frequently (every commit)
# âœ… Dependencies change rarely (major updates)
# âœ… Keeps dependency layer cached during development
#
# ğŸ”§ PRODUCTION TIP: Use .dockerignore
# Exclude: __pycache__, .git, .env, *.pyc, .pytest_cache
# Reduces context size and improves security

COPY . .

# ğŸ§ª HANDS-ON LAB 7: CONTAINER SECURITY HARDENING
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# ğŸ“š THEORY: Why Non-Root Containers?
#
# Security Benefits:
# âœ… Principle of least privilege
# âœ… Limits damage if container is compromised
# âœ… Prevents privilege escalation attacks
# âœ… Required by many Kubernetes security policies
#
# ğŸ”’ DEVSECOPS BEST PRACTICE:
# â€¢ Never run containers as root in production
# â€¢ Use specific UID/GID for consistency
# â€¢ Set proper file permissions
#
# ğŸ¢ COMPLIANCE: Required for SOC2, PCI-DSS, HIPAA

RUN adduser --disabled-password --gecos '' --uid 1001 appuser && \
    chown -R appuser:appuser /app
USER appuser

# ğŸ§ª HANDS-ON LAB 8: CONTAINER NETWORKING
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# ğŸ“š THEORY: Docker Port Exposure
#
# EXPOSE vs -p flag:
# â€¢ EXPOSE: Documents which port app uses (metadata only)
# â€¢ -p flag: Actually maps host port to container port
#
# ğŸŒ NETWORKING CONCEPTS:
# â€¢ Container has its own network namespace
# â€¢ Port 5000 inside container != port 5000 on host
# â€¢ Load balancers route traffic to exposed ports
#
# ğŸ”§ KUBERNETES INTEGRATION:
# Service objects use EXPOSE information for port mapping

EXPOSE 5000

# ğŸ§ª HANDS-ON LAB 9: SRE HEALTH CHECK MONITORING
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# ğŸ“š THEORY: Container Health Check Strategy
#
# Health Check Parameters Explained:
# â€¢ --interval=30s: Check every 30 seconds
# â€¢ --timeout=10s: Fail if check takes >10s
# â€¢ --start-period=40s: Grace period for app startup
# â€¢ --retries=3: Mark unhealthy after 3 failures
#
# ğŸ”§ SRE INTEGRATION:
# â€¢ Docker Swarm: Restart unhealthy containers
# â€¢ Kubernetes: Uses for liveness/readiness probes
# â€¢ AWS ECS: Integrates with Application Load Balancer
# â€¢ Monitoring: Prometheus can scrape health status
#
# ğŸš¨ ALERTING: Failed health checks trigger incident response


HEALTHCHECK --interval=30s --timeout=10s --start-period=40s --retries=3 \
    CMD curl -f http://localhost:5000/health || exit 1

# ğŸ§ª HANDS-ON LAB 10: PRODUCTION ENVIRONMENT CONFIGURATION
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# ğŸ“š THEORY: Container Environment Variables
#
# FLASK_ENV=production:
# âœ… Disables debug mode (security)
# âœ… Enables optimizations
# âœ… Hides sensitive error details
#
# PYTHONUNBUFFERED=1:
# âœ… Forces stdout/stderr to be unbuffered
# âœ… Ensures logs appear immediately
# âœ… Critical for container log aggregation
# âœ… Required for proper Kubernetes logging
#
# ğŸ”§ CLOUD NATIVE PATTERN:
# Environment variables are the standard way to configure
# containerized applications across all cloud platforms

ENV FLASK_ENV=production \
    PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1 \
    PATH="/home/appuser/.local/bin:$PATH"

# ğŸ§ª HANDS-ON LAB 11: PRODUCTION-GRADE APPLICATION SERVER
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# ğŸ“š THEORY: Why Gunicorn over Flask Dev Server?
#
# Flask Development Server:
# âŒ Single-threaded (can't handle concurrent requests)
# âŒ Not designed for production load
# âŒ No process management
# âŒ Poor performance under load
#
# Gunicorn (Green Unicorn):
# âœ… Multi-worker process model
# âœ… Handles thousands of concurrent requests
# âœ… Automatic worker restart on failure
# âœ… Production-tested by Instagram, Pinterest
#
# ğŸš€ PERFORMANCE TUNING:
# â€¢ --workers 4: One worker per CPU core (typical)
# â€¢ --bind 0.0.0.0:5000: Listen on all interfaces
# â€¢ --timeout 120: Request timeout (adjust for your API)
# â€¢ --max-requests 1000: Restart workers after 1000 requests (memory management)
#
# ğŸ”§ SRE MONITORING INTEGRATION:
# Gunicorn provides metrics for Prometheus monitoring


# TEMPORARY FIX: Use Flask dev server for debugging
CMD ["python", "app.py"]

# PRODUCTION VERSION (uncomment when working):
# CMD ["gunicorn", \
#      "--bind", "0.0.0.0:5000", \
#      "--workers", "4", \
#      "--timeout", "120", \
#      "--max-requests", "1000", \
#      "--max-requests-jitter", "100", \
#      "--access-logfile", "-", \
#      "--error-logfile", "-", \
#      "app:app"]

# ï¿½ DOCKER MASTERY CHECKLIST - VALIDATE YOUR LEARNING:
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
#
# âœ… CONTAINERIZATION FUNDAMENTALS:
# â–¡ Can you explain the difference between images and containers?
# â–¡ Do you understand Docker layer caching and optimization?
# â–¡ Can you implement multi-stage builds for production?
# â–¡ Do you know how to minimize container attack surface?
#
# âœ… SECURITY & COMPLIANCE:
# â–¡ Can you create non-root containers for production?
# â–¡ Do you understand container security scanning?
# â–¡ Can you implement secrets management in containers?
# â–¡ Do you know container compliance requirements (SOC2, PCI-DSS)?
#
# âœ… MONITORING & OBSERVABILITY:
# â–¡ Can you implement effective health checks?
# â–¡ Do you understand container logging best practices?
# â–¡ Can you integrate with monitoring systems (Prometheus)?
# â–¡ Do you know how to debug container issues?
#
# ğŸ“š ADDITIONAL LEARNING RESOURCES:
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
#
# ğŸ“– BOOKS:
# â€¢ "Docker Deep Dive" by Nigel Poulton
# â€¢ "Docker in Action" by Jeff Nickoloff
# â€¢ "Kubernetes in Action" by Marko LukÅ¡a
#
# ğŸ“ CERTIFICATIONS:
# â€¢ Docker Certified Associate (DCA)
# â€¢ Certified Kubernetes Administrator (CKA)
# â€¢ AWS Certified Solutions Architect
#
# ğŸ› ï¸ HANDS-ON PRACTICE:
# â€¢ Build multi-stage Dockerfiles for different languages
# â€¢ Practice container security scanning with Trivy/Snyk
# â€¢ Set up container monitoring with Prometheus + Grafana
# â€¢ Deploy containers to Kubernetes clusters
#
# ï¿½ CAREER PROGRESSION:
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
#
# DevOps Engineer ($86K-$190K):
# â€¢ Master container orchestration and CI/CD pipelines
# â€¢ Learn infrastructure as code with Docker + Terraform
#
# SRE Engineer ($95K-$204K):
# â€¢ Focus on container monitoring and reliability patterns
# â€¢ Master Kubernetes operations and incident response
#
# Cloud Engineer ($90K-$165K):
# â€¢ Specialize in cloud-native container platforms
# â€¢ Learn serverless containers (AWS Fargate, Google Cloud Run)
#
# ï¿½ ESSENTIAL DOCKER COMMANDS FOR PRODUCTION:
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
#
# BUILD & RUN:
# docker build -t onepiece-character-service:latest .
# docker run -d -p 5000:5000 --name character-api onepiece-character-service
#
# MONITORING & DEBUGGING:
# docker ps                                    # List running containers
# docker logs -f character-api                 # Follow container logs
# docker exec -it character-api bash           # Enter container shell
# docker stats character-api                   # Monitor resource usage
#
# PRODUCTION DEPLOYMENT:
# docker build -t onepiece-character-service:v1.0.0 .
# docker tag onepiece-character-service:v1.0.0 your-registry/onepiece-character-service:v1.0.0
# docker push your-registry/onepiece-character-service:v1.0.0
#
# SECURITY SCANNING:
# docker scan onepiece-character-service       # Scan for vulnerabilities
# trivy image onepiece-character-service       # Advanced security scanning
#
# ğŸ¯ NEXT LEARNING MODULES:
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
#
# 1. ğŸ³ Docker Compose - Multi-service orchestration
# 2. â˜¸ï¸  Kubernetes - Container orchestration at scale
# 3. ğŸ“Š Monitoring - Prometheus metrics and Grafana dashboards
# 4. ğŸ” Security - Container scanning and hardening
# 5. ğŸš€ CI/CD - Automated container builds and deployments
#
# CONGRATULATIONS! You've mastered Docker containerization! ğŸ´â€â˜ ï¸âš”ï¸
