# ğŸ´â€â˜ ï¸ SRE MASTERY: DOCKER COMPOSE ORCHESTRATION BLUEPRINT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# ğŸ¯ LEARNING OBJECTIVES - BECOME A MICROSERVICES ORCHESTRATION EXPERT:
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# âœ… Master multi-service application orchestration patterns
# âœ… Implement service discovery and inter-service communication
# âœ… Learn database clustering and data persistence strategies
# âœ… Practice environment-based configuration management
# âœ… Understand load balancing and horizontal scaling
# âœ… Implement comprehensive health checking and monitoring
#
# ğŸ“– DEVOPS THEORY: MICROSERVICES ORCHESTRATION
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# Docker Compose solves complex multi-service challenges:
#
# 1. ğŸŒ SERVICE DISCOVERY - Services find each other by name
# 2. ğŸ”— NETWORKING - Isolated networks for security
# 3. ğŸ’¾ DATA PERSISTENCE - Volumes survive container restarts
# 4. ğŸ”„ DEPENDENCY MANAGEMENT - Services start in correct order
# 5. ğŸ“Š MONITORING - Health checks and log aggregation
# 6. ğŸš€ SCALING - Horizontal scaling with load balancing
#
# ğŸ”§ REAL-WORLD SRE/DEVOPS CONNECTION:
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# This orchestration pattern is used by:
# â€¢ Netflix: Microservices architecture with service mesh
# â€¢ Uber: Multi-region service deployment and scaling
# â€¢ Airbnb: Development environment standardization
# â€¢ Spotify: Feature team service isolation
# â€¢ Amazon: ECS task definitions mirror Compose patterns

# ğŸ§ª HANDS-ON LAB 1: COMPOSE FILE VERSION STRATEGY
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# ğŸ“š THEORY: Docker Compose Version Selection
#
# Version History & Features:
# â€¢ 3.8: Latest stable, supports all modern features
# â€¢ 3.7: GPU support, external secrets
# â€¢ 3.6: Configs, deploy placement constraints
# â€¢ 3.5: Isolation mode, external networks
#
# ğŸ”§ PRODUCTION CHOICE: 3.8
# âœ… Full feature support for modern deployments
# âœ… Compatible with Docker Swarm mode
# âœ… Supports external configs and secrets
# âœ… Best performance and stability

version: '3.8'

# ğŸ§ª HANDS-ON LAB 2: MICROSERVICES ARCHITECTURE DESIGN
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# ğŸ“š THEORY: Service Definition Strategy
#
# Each service represents a microservice with:
# âœ… Single responsibility (character management)
# âœ… Independent deployment and scaling
# âœ… Isolated failure domains
# âœ… Clear API boundaries
#
# ğŸ”§ SRE PATTERN: Service Mesh Architecture
# This mirrors production service mesh patterns used by:
# â€¢ Istio (Google/IBM)
# â€¢ Linkerd (Buoyant)
# â€¢ Consul Connect (HashiCorp)

services:

  # ğŸ§ª HANDS-ON LAB 3: APPLICATION SERVICE CONFIGURATION
  # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  # ğŸ“š THEORY: Container Build vs Image Strategy
  #
  # build: . (Development)
  # âœ… Builds from local Dockerfile
  # âœ… Fast iteration during development
  # âœ… Includes latest code changes
  #
  # image: registry/app:tag (Production)
  # âœ… Uses pre-built, tested images
  # âœ… Consistent deployments
  # âœ… Faster startup times
  #
  # ğŸ”§ DEVOPS BEST PRACTICE:
  # Use build for dev, image for production

  
  
  character-service:
    build: .
    container_name: onepiece-character-api

    # ğŸ§ª HANDS-ON LAB 4: NETWORK PORT MANAGEMENT
    # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    # ğŸ“š THEORY: Port Mapping Strategy
    #
    # Format: "host_port:container_port"
    # â€¢ 5000:5000 - Direct mapping (simple)
    # â€¢ 80:5000 - Standard HTTP port mapping
    # â€¢ 127.0.0.1:5000:5000 - Localhost only (security)
    #
    # ğŸ”’ SECURITY CONSIDERATION:
    # Only expose ports that need external access


    ports:
      - "5000:5000"

    # ğŸ§ª HANDS-ON LAB 5: ENVIRONMENT-BASED CONFIGURATION
    # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    # ğŸ“š THEORY: 12-Factor App Configuration
    #
    # Environment variables enable:
    # âœ… Environment-specific configuration
    # âœ… Secret management (don't hardcode passwords)
    # âœ… Easy deployment across environments
    # âœ… Runtime configuration changes
    #
    # ğŸ”§ CLOUD NATIVE PATTERN:
    # All major cloud platforms use environment variables

    environment:
      - FLASK_ENV=development
      - PYTHONUNBUFFERED=1
      - DB_HOST=mysql
      - DB_PORT=3306
      - DB_USER=root
      - DB_PASSWORD=onepiece123
      - DB_NAME=onepiece_market
      - REDIS_HOST=redis
      - REDIS_PORT=6379

    # ğŸ§ª HANDS-ON LAB 6: SERVICE DEPENDENCY MANAGEMENT
    # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    # ğŸ“š THEORY: Startup Order and Health Checks
    #
    # depends_on ensures:
    # âœ… Services start in correct order
    # âœ… Dependencies are available before app starts
    # âŒ Does NOT wait for service to be "ready"
    #
    # ğŸ”§ SRE BEST PRACTICE:
    # Combine depends_on with health checks and retry logic

    depends_on:
      - mysql
      - redis

    # ğŸ§ª HANDS-ON LAB 7: CONTAINER RESTART POLICIES
    # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    # ğŸ“š THEORY: Restart Policy Options
    #
    # â€¢ no: Never restart (default)
    # â€¢ always: Always restart on failure
    # â€¢ on-failure: Restart only on non-zero exit
    # â€¢ unless-stopped: Restart unless manually stopped
    #
    # ğŸ”§ SRE CHOICE: unless-stopped
    # âœ… Survives host reboots
    # âœ… Respects manual stops
    # âœ… Handles application crashes

    restart: unless-stopped

    # ğŸ§ª HANDS-ON LAB 8: HEALTH CHECK INTEGRATION
    # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    # ğŸ“š THEORY: Container Health Monitoring
    #
    # Health checks enable:
    # âœ… Automatic unhealthy container restart
    # âœ… Load balancer integration
    # âœ… Monitoring system integration
    # âœ… Deployment readiness validation
    #
    # ğŸ”§ KUBERNETES INTEGRATION:
    # These health checks translate to liveness/readiness probes

    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:5000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    #   - redis
    # Volumes for development (code changes reflect immediately)
    # volumes:
    #   - .:/app
    # Restart policy
    # restart: unless-stopped

  # TODO 4: MYSQL DATABASE SERVICE
  # mysql:
    # Use official MySQL image
    # image: mysql:8.0
    # Container name
    # container_name: onepiece-mysql
    # Environment variables for MySQL setup
    # environment:
    #   - MYSQL_ROOT_PASSWORD=onepiece123
    #   - MYSQL_DATABASE=onepiece_market
    #   - MYSQL_USER=onepiece_user
    #   - MYSQL_PASSWORD=onepiece123
    # Port mapping
    # ports:
    #   - "3306:3306"
    # Volume for data persistence
    # volumes:
    #   - mysql_data:/var/lib/mysql
    #   - ./database/schema.sql:/docker-entrypoint-initdb.d/01-schema.sql
    #   - ./database/sample_data.sql:/docker-entrypoint-initdb.d/02-data.sql
    # Restart policy
    # restart: unless-stopped
    # Health check
    # healthcheck:
    #   test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
    #   timeout: 20s
    #   retries: 10

  # TODO 5: REDIS CACHE SERVICE
  # redis:
    # Use official Redis image
    # image: redis:7-alpine
    # Container name
    # container_name: onepiece-redis
    # Port mapping
    # ports:
    #   - "6379:6379"
    # Command to run Redis with password
    # command: redis-server --requirepass onepiece123
    # Restart policy
    # restart: unless-stopped
    # Health check
    # healthcheck:
    #   test: ["CMD", "redis-cli", "ping"]
    #   interval: 30s
    #   timeout: 10s
    #   retries: 5

  # TODO 6: ADMINER (Database Management Tool)
  # adminer:
    # Database management web interface
    # image: adminer
    # container_name: onepiece-adminer
    # Port mapping
    # ports:
    #   - "8080:8080"
    # Depends on MySQL
    # depends_on:
    #   - mysql
    # Restart policy
    # restart: unless-stopped

# TODO 7: DEFINE VOLUMES
# volumes:
  # Persistent storage for MySQL data
  # mysql_data:

# TODO 8: DEFINE NETWORKS (Optional)
# networks:
  # onepiece_network:
    # driver: bridge

"""
ğŸ¯ WHAT EACH SERVICE DOES:

character-service: Your Flask API application
mysql: Database server for storing character data
redis: Cache server for session management and performance
adminer: Web-based database management tool

ğŸš€ DOCKER COMPOSE CONCEPTS:

1. Multi-container applications
2. Service dependencies (depends_on)
3. Environment variable management
4. Volume mounting for data persistence
5. Network communication between containers
6. Health checks for service monitoring
7. Restart policies for reliability

ğŸ“š DOCKER COMPOSE COMMANDS:

docker-compose up -d          # Start all services in background
docker-compose down           # Stop and remove all services
docker-compose logs           # View logs from all services
docker-compose ps             # List running services
docker-compose exec mysql bash  # Enter MySQL container
docker-compose restart character-service  # Restart specific service

ğŸ”§ DEVELOPMENT WORKFLOW:

1. docker-compose up -d mysql redis    # Start dependencies first
2. Wait for MySQL to be ready
3. docker-compose up character-service # Start your API
4. Access Adminer at http://localhost:8080 for database management
5. Your API runs at http://localhost:5001

ğŸŒ SERVICE URLS:

Flask API: http://localhost:5001
MySQL: localhost:3306
Redis: localhost:6379
Adminer: http://localhost:8080

ğŸ“Š ADMINER LOGIN:
Server: mysql
Username: root
Password: onepiece123
Database: onepiece_market

PRODUCTION NOTES:
- Change default passwords
- Use secrets management
- Configure proper networks
- Set up monitoring and logging
- Use production-ready images

NEXT FILE AFTER THIS: Create application runner script! ğŸš€
"""
